
Week1 : <클린코드> 1~4장 내용 정리


# 1장. 깨끗한 코드

르블랑의 법칙 : 나중은 결코 오지 않는다. 나중에 손보겠다고 한 코드를 작성하면 돌아간다는 사실에 안도감을 느끼며 위로하게 되고 결국 고치지 않게 된다.

나쁜 코드가 생기는 이유는 가지각각 이지만 전적으로 프로그래머 잘못이다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로  따르는 행동은 전문가답지 못하다.

나쁜 코드는 업무 속도를 늦춘다. 빨리 가는 유일한 방법은 언케나 코드를 최대한 깨끗하게 유지하는 습관.
<br><br><br>
**깨진 유리창 법칙**

나쁜 코드는 나쁜 코드를 유혹한다.
<br><br><br>
******************************보이스카우트 규칙******************************

나쁜 코드를 발견하면 원래 코드를 작성한 사람이 누구이건 간에, 좋은 코드로 개선하려는 노력이 필요하다
<br><br><br>
**************************깨끗한 코드란**************************

- 철저한 오류 처리
- 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다
- 단위 테스트 케이스와 인수 테스트 케이스가 존재
- 특정 목적을 달성하는 방법은 하나만 제공한다
- 모든 테스트를 통과한다
- 중복이 없다
- 시스템 내 모든 설계 아이디어를 표현한다
- 클래스, 메서드, 함수 등을 최대한 줄인다
- 코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다

<br><br>
**우리는 저자(author)다**

저자에게는 독자와 잘 소통할 책임이 있다.

<br><br><br>

# 2장. 의미 있는 이름

변수, 함수 이름은 존재 이유, 수행 기능, 사용 방법을 나타내야 한다.
주석이 필요하면 의도가 불분명한 것.

<br><br>
**그릇된 정보를 피하라**

실제 리스트가 아니라면 ex. accountList라고 이름짓지 않는다. 
실제 리스트라도 이름에 컨테이너 유형 안넣는게 좋다. ex. Account**s**


<br><br>
**의미 있게 구분하라**

연속된 숫자 덧붙이거나(a1, a2, ..) 불용어(noise word) 추가하지 않는다.
이름이 달라야 한다면 의미도 달라야한다.

- a1, a2 —>dest, src
- productInfo, productData X
- 접두사 a : 지역 변수, the: 함수인수
- 변수 이름에 variable, table 금지

<br><br>
**발음하기 쉬운 이름을 이용하라**

ex. genymdhms (generate date, year, month, …) —> generationTimestamp

<br><br>
**검색하기 쉬운 이름을 사용하라**

문자 하나 사용하는 이름과 상수는 검색이 잘 안된다.

ex. 7 —> MAX_CLASSES_PER_STUDENT

간단한 메서드에서 로컬 변수만 한 문자를 사용한다. 

이름 길이는 범위 크기에 비례해야 한다.

<br><br><br>
********************************인코딩을 피하라********************************

유형이나 범위 정보까지 인코딩에 넣으면 이름 해독하기 어려워진다. 요즘 프로그래밍 언어는 변수 이름에 타입을 인코딩할 필요가 없다. 

<br><br>
**********************************멤버 변수 접두어는 필요없다**********************************

클래스와 함수는 접두어가 필요없을 정도로 작아야 한다.

<br><br>
**************************************************************************인터페이스 클래스와 구현 클래스의 인코딩************************************************************************** 

shapeFactory & shapeFactoryImp 가 CShapeFactory & IShapeFactory 보다 낫다.

<br><br>
**자신의 기억력을 자랑하지 마라**

그 변수가 뭘 뜻하는지 혼자만 알면 안됨. 독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 변수 이름을 잘못 지은것. 명료함이 최고.

<br><br>
**************************클래스, 객체 이름**************************

명사, 명사구가 적합.

- 좋은 예 : Customer, Account
- 나쁜 예 : Manager, Data, Info, Processor, 동사

<br><br>
**메서드 이름**

동사, 동사구 적합.

접근자, 변경자, 조건자는 값 앞에 get, set, is 붙인다.

생성자를 오버로드할 때는 정적 팩토리 메서드를 사용한다. 메서드는 인수를 설명하는 이름을 사용한다.

Complex point = new Complex(23); —> Complex point = Complex.FromInteger(23);

생성자 사용을 제한하려면 해당 생성자를 private 선언한다.


<br><br><br>
 ******************************************기발한 이름은 피하라******************************************

특정 문화에서만 사용하는 농담은 피한다.

<br><br>
**한 개념에 한 단어를 사용하라**

똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다.

동일 코드 기반에 controller, manager, driver를 섞어 쓰면 혼란스럽다.

일관성 있는 코드를 써라.

이름이 다르면 독자는 클래스도 다르고 타입도 다르리라고 생각한다.

<br><br>
**말장난을 하지마라**

한 단어를 2가지 목적으로 사용하지 마라.

여러 클래스에 add라는 메서드가 있을 떄, 모든 add 메서드의 매개변수와 반환값이 의미적으로 동일하면 문제 없다.

기존 add 메서드와 맥락이 다르게 쓰일 경우 insert, append 이름을 쓴다.

의도를 밝힐 책임은 저자에게 있다.

<br><br>
**해법 영역에서 가져온 이름을 사용하라**

모든 이름을 문제영역(도메인)에서 가져오는 것은 별로다. 매번 고객에게 의미를 물어보게된다.

기술 개념에는 기술 이름이 가장 적합하다. ex. Job**Queue**

<br><br>
**문제 영역에서 가져온 이름을 사용하라**

적절한 프로그래머 용어가 없다면 문제영역에서 이름을 가져온다.

프로그래머는 해법 영역과 문재 영역을 구분할 줄 알아야 한다.

문제 영역 관련 코드라면 문제 영역 관련 이름을 써야 한다.

<br><br>
********************************************************의미 있는 맥락을 추가하라********************************************************

클래스, 함수, 이름 공간에 분명한 이름 넣기 실패하면 마지막 수단으로 **접두어**를 붙인다.

firstName, lastName, street, city, state .. —> addr 접두어 추가, 또는 Address 클래스 생성.

긴 함수 —> 클래스를 만들고 변수를 클래스에 넣은 뒤 함수를 쪼갠다.

<br><br>
**불필요한 맥락을 없애라**

일반적으로는 짧은 이름이 좋지만, 의미가 분명한 경우에 한해서이다.

accountAdress, customerAdress 는 클래스 이름보다는 Adress 클래스의 인스턴스로 적합하다.

클래스, 메서드 이름 암기는 도구에게 맡기고, 우리는 문장처럼 읽히는 코드, 표나 자료구조처럼 읽히는 코드를 짜는 데 집중해야 한다.

<br><br>
# 3장. 함수

어떤 프로그램이든 가장 기본적인 단위는 함수.

<br><br>
**함수를 작게 만들어라**

함수당 6줄 정도로.

<br><br>
**블록과 들여쓰기**

if, else, while 문 등에 들어가는 블록은 한 줄이어야 한다.

함수에서 들여쓰기 수준은 2단을 넘어서는 안된다.

중첩 구조가 생길만큼 함수가 커져서는 안된다. 함수 가독성 증가 목적.

<br><br>
********************************************************************함수는 한 가지를 해야 한다********************************************************************

그 한 가지를 잘 하고, 그 한가지만을 해야 한다.

지정된 함구 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 우리가 함수를 만드는 이유는 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서이다.

함수를 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

한 함수 내에 여러 섹션이 존재한다면 여러 작업을 한다는 뜻이다.

<br><br>
**함수당 추상화 수준은 하나로**

함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

함수 내에 추상화 수준을 섞으면 코드 읽는 사람이 헷갈린다. 근본 개념과 세부사항을 뒤섞기 시작하면 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

<br><br>
**위에서 아애로 코드 읽기: 내려가기 규칙**

위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

<br><br>
**Switch 문**

switch문은 작게 만들기 어렵고, N가지를 처리한다. 

switch 문을 꼭 써야할 때는 다형성을 이용한다. 

switch를 추상 팩토리에 숨기고 절대로 반복하지 않는다.

예제에서 팩토리에서는 적절한 Employee 파생 클래스의 인스턴스를 생성하고, calculatePay, isPayDat 등의 함수를 Employee 인터페이스를 거쳐 호출한다.

- 문제의 코드

```markdown
public Money calculatePay(Employee e) throws InvalidEmployeeType {
  switch (e.type) {
    case COMMISIONED :
      return calculateCommissionedPay(e);
    case HOURLY :
      return calculateHourlyPay(e);
    case SALARIED :
      return calculateSalariedPay(e);
    default :
      throw new InvalidEmployeeType(e.type);
  }
}
```

- 개선된 코드

```markdown
// 추상 클래스 Employee
public abstract class Employee {
  public abstract boolean isPayday();
  public abstract boolean calculatePay();
  public abstract boolean deliverPay(Money pay);
}

// Employee를 상속 받는 객체들을 생성할 수 있는 EmployeeFactory 인터페이스
public interface EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

// EmployeeFactory를 구현한 클래스
public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISIONED :
        return new CommissionedEmployee(r);
      case HOURLY :
        return new HourlyEmployee(r);
      case SALARIED :
        return new SalariedEmployee(r);
      default :
        throw new InvalidEmployeeType(r.type);
    }
  }
}
```

<br><br>
******************************************************서술적인 이름을 사용하라******************************************************

testableHtml —> SetupTeardownIncluder

이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.

길고 서술적인 이름이 길고 서술적인 주석보다 좋다.

이름을 붙일 때는 일관성이 있어야 한다.

<br><br>
**함수 인수**

함수에서 이상적인 인수 개수는 0개이다. 3개는 가능한 피하는 게 좋다.

인수는 개념을 이해하기 어렵게 한다. 인수가 3개를 넘어가면 테스트할 떄 조합 구성하기 부담스럽다.

<br><br>
**많이 쓰는 단항 형식**

함수에 인수가 1개 넘기는 이유: 

- 인수에 질문 던지는 경우 : boolean fileExists(”MyFile”)
- 인수를 뭔가로 변환해 결과 반환하는 경우 :  InputStream fileOpen(”MyFile”)

이벤트 함수는 입력 인수만 있고 출력 인수는 없다. 프로그램은 함수 호출을 이벤트로 해석해서 입력 인수로 시스템 상태를 바꾼다. ex. passwordAttemptFailedNtimes(int attempt)

위의 3가지 경우가 아니라면 단항 함수는 가급적 피한다. 

변환함수에서 출력인수를 사용하면 혼란스럽다. 입력 인수를 그대로 돌려주는 함수라도 변환 함수 형식을 따르는 편이 좋다.

<br><br>
************************플래그 인수************************

플래그 인수는 추하다. 함수가 여러가지를 처리한다고 대놓고 공표하는 셈이다.

<br><br>
**이항 함수**

직교좌표계 점은 일반적으로 인수 2개를 쓰지만, 이 경우는 한 값을 표현하는 두 요소이다.

자연적인 순서가 없는 이항 함수는 헷갈린다. ex. assertEquals(expected, actual) 

이항 함수는 가능하면 단항 함수로 바꾸는게 좋다.

<br><br>
**삼항 함수**

인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 때문에 삼항 함수를 만들 때는 신중히 고려해야 한다.

<br><br>
**인수 객체**

인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언하는 것을 고려해본다.

Circle makeCircle(double x, double y, double radius) -> Circle makeCircle(Point center, double radius)

<br><br>
**인수 목록**

인수 개수가 가변적인 함수에서, 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다.

public String format(String format, Object... args)

가변 인수를 포함해 인수 개수가 3개가 넘어가면 안된다.

<br><br>
****************************동사와 키워드****************************

단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. ex. writeField(name)

assertEquals —> assertExpectedEqualsActual(expected, actual)

<br><br>
**************************************************부수 효과를 일으키지 마라**************************************************

함수 이름으로 명시된 한 가지 일 외에 다른 일이 포함되는 부수 효과(Side Effect)가 발생하는 경우를 조심해야 한다. 

함수가 한 가지일을 하게 만드는 게 좋지만 어쩔 수 없다면 차라리 함수 이름에 다른 일에 대한 것을 분명히 명시하는 게 낫다.

<br><br>
**출력 인수**

일반적으로 인수를 함수의 입력, 반환값을 출력으로 생각하기 때문에 인수를 출력으로 사용하지 않게 조심해야 한다.

<br><br>
****************************************************명령과 조회를 분리하라****************************************************

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 하지, 둘 다 하면 안 된다.

<br><br>
********************오류 코드보다 예외를 사용하라********************

함수에서 오류 코드를 사용하게 되면 오류 코드에 관련된 처리를 추가적으로 해주어야 한다. 

때문에 오류 코드 대신 예외를 사용하면 오류 처리 코드가 분리되므로 코드가 더 깔끔해진다.

- try/catch 블록 뽑아내기 : 별도 함수로 뽑아낸다.

<br><br>
**오류 처리도 한 가지 작업이다**
함수는 한 가지 일만해야 하는데, 오류 처리도 한 가지 작업에 속한다. 오류를 처리하는 함수는 오류만 처리해야 한다.

<br><br>
******************************반복하지 마라******************************

중복이 발생한다면 코드 길이가 늘어날 뿐 아니라 중복 코드가 변하면 중복된 부분 모두를 수정해야 하기 때문에 오류가 발생할 확률도 높아지게 된다.

구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 모두 어떤 면에서는 중복 제거 전략이다.

- AOP(Aspect Oriented Programming) : 관점 지향 프로그래밍. 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 묘듈화 하는 것을 말한다.
- COP(Component Oriented Programming) : Vue, React, Angular 등.. 에서 사용하는 컴포넌트 지향 프로그래밍. 프론트 엔드에서 반복되는 요소들을 컴포넌트로 분리하여 애플리케이션을 더 빠르게 구축할 수 있게 해주는 것을 말한다.

<br><br>
********************************************구조적 프로그래밍********************************************

모든 함수와 함수 내 모든 블록에는 입구와 출구가 하나만 존재해야 한다.

(입/출구 규칙) 때문에 break, continue는 사용해선 안 되고 goto는 절대로 사용하지 않는다.

하지만 함수를 작게 만든다면 때로는 입/출구 규칙 보다 아래의 예시 처럼 return, break ,continue를 사용하는 게 의도를 표현하기 쉬워지기 때문에 적절히만 사용한다면 괜찮다.

<br><br>
********************************************함수를 어떻게 짜나?********************************************

처음에는 길고 복잡한 코드로 짜지만, 그걸 빠짐없이 테스트하는단위 테스트 케이스를 만든다.

그다음 함수를 쪼개고, 이름을 바꾸고, 중복 제거를 한다.

<br><br>
# 4. 주석

나쁜 코드에 주석을 달지 마라. 코드를 새로 짜라.

코드는 변화하지만, 주석이 언제나 코드를 따라가지는 않는다.

부정확한 주석은 아예 없는 주석보다 나쁘다.

더 이상 지킬 필요가 없는 규칙이나 지켜서는 안되는 규칙을 명시해서는 안된다.

********************************************************************************주석은 나쁜 코드를 보완하지 못한다********************************************************************************

************************************************코드로 의도를 표현하라************************************************

많은 경우 주석으로 달려는 설명은 함수로 만들어 표현해도 충분하다.

## ********************4-1. 좋은 주석********************

- **************************법적인 주석**************************
- **********************************************정보를 제공하는 주석**********************************************
- **의도를 설명하는 주석**
- **의미를 명료하게 밝히는 주석**
    - 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속할 때 유용.
- **결과를 경고하는 주석**
- **TODO 주석**
- **중요성을 강조하는 주석**
- **공개 API에서 Javadocs**

## 4-2. 나쁜 주석

함수나 변수로 표현할 수 있다면 주석을 달지 마라.

- 주절거리는 주석 : 해석 불가, 코드보다 읽는데 시간 더 걸림
- 같은 이야기를 중복하는 주석
- 오해할 여지가 있는 주석
- 의무적으로 다는 주석
- 이력을 기록하는 주석 : 소스 코드 관리 시스템에게 맡겨라
- 있으나마나 한 주석 : 너무 당연한 사실 언급해서 새로운 정보 제공X
- 무서운 잡음 : 붙여넣기 오류 등
- 위치를 표시하는 주석 : 배너는 반드시 필요할 때만 드물게 사용.
- 닫는 괄호에 다는 주석 : 중첩 심할 때만 사용. 대신 함수 크기를 줄이자
- 공로를 돌리거나 저자를 표시하는 주석 : 소스 코드 관리 시스템에게 맡기자
- 주석으로 처리한 코드 : 중요하니깐 지우면 안된다고 생각해서 쓸모없는 코드가 쌓인다. 소스코드관리시스템에게 코드 기억을 맡기자. 주석을 삭제해라.
- HTML 주석 : 읽기 어렵다
- 전역 정보 : 근처의 코드에 대해서만 기술해라.
- 너무 많은 정보  : 흥미로운 내용이나 역사 쓰지 마라
- 모호한 관계 : 주석과 그것이 설명하는 코드의 관계가 명백해야 한다.
- 함수 헤더 : 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가 주석으로 헤더를 추가한 함수보다 좋다.
- 비공개 코드에서 Javadocs